# -*- coding: utf-8 -*-
"""fire_dashboard.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1V0Icu1Q3qw2oCNqaxwVo97N_bxPM39wX
"""

import streamlit as st
import pandas as pd
import numpy as np
import requests
from io import StringIO
from pydub import AudioSegment
from pydub.generators import Sine, WhiteNoise

# ---------------- Funções auxiliares ----------------
def distance_km(lat1, lon1, lat2, lon2):
    R = 6371
    dlat = np.radians(lat2 - lat1)
    dlon = np.radians(lon2 - lon1)
    a = np.sin(dlat/2)**2 + np.cos(np.radians(lat1))*np.cos(np.radians(lat2))*np.sin(dlon/2)**2
    return 2 * R * np.arcsin(np.sqrt(a))

def humming(frequency, duration_ms, amplitude=0.2):
    humming_sound = Sine(frequency).to_audio_segment(duration=duration_ms)
    humming_sound = humming_sound.fade_in(int(duration_ms*0.05)).fade_out(int(duration_ms*0.05))
    humming_sound = humming_sound.apply_gain(-30 + amplitude*20)
    return humming_sound

def epic_chord(frequencies, duration_ms, amplitude=0.5):
    chord = AudioSegment.silent(duration=duration_ms)
    pan_positions = [-0.4, 0.4, -0.2, 0.2, 0.0]
    for i, f in enumerate(frequencies):
        note = Sine(f).to_audio_segment(duration=duration_ms)
        note = note.fade_in(int(duration_ms*0.2)).fade_out(int(duration_ms*0.9))
        note = note.apply_gain(-40 + amplitude*35)
        note = note.pan(pan_positions[i % len(pan_positions)])
        chord = chord.overlay(note)
    # Reverb simples
    for i in range(4):
        delay = int(duration_ms * 0.5 * (i+1))
        chord = chord.overlay(chord - (10 + i*5), position=delay)
    noise = WhiteNoise().to_audio_segment(duration=duration_ms).apply_gain(-50)
    chord = chord.overlay(noise)
    return chord

# ---------------- Interface Streamlit ----------------
st.title("🔥 Dashboard Musical de Incêndios - FIRMS")

st.sidebar.header("Parâmetros de entrada")
map_key = st.sidebar.text_input("FIRMS API Key", type="password")
latitude_center = st.sidebar.number_input("Latitude central", value=-3.0)
longitude_center = st.sidebar.number_input("Longitude central", value=-63.0)
radius_km = st.sidebar.number_input("Raio (km)", value=500)
data_date = st.sidebar.text_input("Data (YYYY-MM-DD)", value="2025-10-14")
day_range = st.sidebar.number_input("Dias a buscar", value=7)

if st.sidebar.button("🎵 Gerar som"):
    if not map_key:
        st.warning("Insira sua API key do FIRMS!")
    else:
        try:
            url = f"https://firms.modaps.eosdis.nasa.gov/api/area/csv/{map_key}/MODIS_SP/world/{day_range}/{data_date}"
            response = requests.get(url)
            if response.status_code != 200:
                st.error(f"Erro ao buscar dados: {response.status_code}")
            else:
                df = pd.read_csv(StringIO(response.text))
                df['dist_km'] = distance_km(latitude_center, longitude_center, df['latitude'], df['longitude'])
                df_local = df[df['dist_km'] <= radius_km].copy()

                if df_local.empty:
                    st.warning("Nenhum foco encontrado nessa área e período.")
                else:
                    focos_por_dia = df_local.groupby('acq_date').size()
                    max_focos = focos_por_dia.max()
                    min_focos = focos_por_dia.min()

                    notes_penta = [130.81, 146.83, 164.81, 174.61, 196.00, 220.00,
                                   246.94, 261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88]

                    melody = AudioSegment.silent(duration=1000)
                    acorde_ms = 4000
                    overlap_ms = 600
                    pause_ms = 100
                    last_note_idx = np.random.randint(1, len(notes_penta)-4)

                    for dia, n_focos in focos_por_dia.items():
                        amplitude = np.interp(n_focos, [min_focos, max_focos], [0.3, 0.7])
                        shift = np.random.randint(-3, 4)
                        note_idx = np.clip(last_note_idx + shift, 1, len(notes_penta)-4)
                        last_note_idx = note_idx
                        f_base = notes_penta[note_idx]
                        intervals = [1, 1.25, 1.5, 2]
                        frequencies = [f_base*x for x in intervals]
                        chord = epic_chord(frequencies, acorde_ms, amplitude)
                        melody = melody.append(chord, crossfade=overlap_ms)
                        melody += AudioSegment.silent(duration=pause_ms)

                    humming_layer = humming(130.81, len(melody))
                    melody = melody.overlay(humming_layer)

                    file_name = "fires_epic_sound.mp3"
                    melody.export(file_name, format="mp3")

                    st.success("🎶 Som gerado com sucesso!")
                    st.audio(file_name, format="audio/mp3")
                    st.download_button("⬇️ Baixar MP3", data=open(file_name, "rb").read(), file_name=file_name)
        except Exception as e:
            st.error(f"Erro inesperado: {e}")